{"version":3,"file":"index.js","sources":["../src/utils.js","../src/hooks/useTableState.js","../src/hooks/useTable.js","../src/hooks/useColumns.js","../src/hooks/useRows.js","../src/actions.js","../src/hooks/useExpanded.js","../src/hooks/useFilters.js","../src/aggregations.js","../src/hooks/useGroupBy.js","../src/hooks/useSortBy.js","../src/hooks/usePagination.js","../src/hooks/useFlexLayout.js","../src/hooks/useTokenPagination.js"],"sourcesContent":["import React from 'react'\n\nexport function getBy(obj, path, def) {\n  if (!path) {\n    return obj\n  }\n  const pathObj = makePathArray(path)\n  let val\n  try {\n    val = pathObj.reduce((cursor, pathPart) => cursor[pathPart], obj)\n  } catch (e) {\n    // continue regardless of error\n  }\n  return typeof val !== 'undefined' ? val : def\n}\n\nexport function defaultOrderByFn(arr, funcs, dirs) {\n  return [...arr].sort((rowA, rowB) => {\n    for (let i = 0; i < funcs.length; i += 1) {\n      const sortFn = funcs[i]\n      const desc = dirs[i] === false || dirs[i] === 'desc'\n      const sortInt = sortFn(rowA, rowB)\n      if (sortInt !== 0) {\n        return desc ? -sortInt : sortInt\n      }\n    }\n    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index\n  })\n}\n\nexport function defaultSortByFn(a, b, desc) {\n  // force null and undefined to the bottom\n  a = a === null || a === undefined ? '' : a\n  b = b === null || b === undefined ? '' : b\n  // force any string values to lowercase\n  a = typeof a === 'string' ? a.toLowerCase() : a\n  b = typeof b === 'string' ? b.toLowerCase() : b\n  // Return either 1 or -1 to indicate a sort priority\n  if (a > b) {\n    return 1\n  }\n  if (a < b) {\n    return -1\n  }\n  // returning 0, undefined or any falsey value will defer to the next\n  // sorting mechanism or eventually the columns index via the orderByFn\n  return 0\n}\n\nexport function getFirstDefined(...args) {\n  for (let i = 0; i < args.length; i += 1) {\n    if (typeof args[i] !== 'undefined') {\n      return args[i]\n    }\n  }\n}\n\nexport function defaultGroupByFn(rows, grouper) {\n  return rows.reduce((prev, row, i) => {\n    const resKey =\n      typeof grouper === 'function'\n        ? grouper(row.values, i)\n        : row.values[grouper]\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : []\n    prev[resKey].push(row)\n    return prev\n  }, {})\n}\n\nexport function defaultFilterFn(row, id, value, column) {\n  return row.values[id] !== undefined\n    ? String(row.values[id])\n      .toLowerCase()\n      .includes(String(value).toLowerCase())\n    : true\n}\n\nexport function setBy(obj = {}, path, value) {\n  const recurse = (obj, depth = 0) => {\n    const key = path[depth]\n    const target = typeof obj[key] !== 'object' ? {} : obj[key]\n    const subValue =\n      depth === path.length - 1 ? value : recurse(target, depth + 1)\n    return {\n      ...obj,\n      [key]: subValue\n    }\n  }\n\n  return recurse(obj)\n}\n\nexport function getElementDimensions(element) {\n  const rect = element.getBoundingClientRect()\n  const style = window.getComputedStyle(element)\n  const margins = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight)\n  }\n  const padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight)\n  }\n  return {\n    left: Math.ceil(rect.left),\n    width: Math.ceil(rect.width),\n    outerWidth: Math.ceil(\n      rect.width + margins.left + margins.right + padding.left + padding.right\n    ),\n    marginLeft: margins.left,\n    marginRight: margins.right,\n    paddingLeft: padding.left,\n    paddingRight: padding.right,\n    scrollWidth: element.scrollWidth\n  }\n}\n\nexport function flexRender(Comp, props) {\n  if (typeof Comp === 'function') {\n    return Object.getPrototypeOf(Comp).isReactComponent ? (\n      <Comp {...props} />\n    ) : (\n      Comp(props)\n    )\n  }\n  return Comp\n}\n\nexport const mergeProps = (...groups) => {\n  let props = {}\n  groups.forEach(({ style = {}, className, ...rest } = {}) => {\n    props = {\n      ...props,\n      ...rest,\n      style: {\n        ...(props.style || {}),\n        ...style\n      },\n      className: [props.className, className].filter(Boolean).join(' ')\n    }\n  })\n  return props\n}\n\nexport const applyHooks = (hooks, initial, ...args) =>\n  hooks.reduce((prev, next) => next(prev, ...args), initial)\n\nexport const applyPropHooks = (hooks, ...args) =>\n  hooks.reduce((prev, next) => mergeProps(prev, next(...args)), {})\n\nexport const warnUnknownProps = props => {\n  if (Object.keys(props).length) {\n    throw new Error(\n      `Unknown options passed to useReactTable:\n      \n${JSON.stringify(props, null, 2)}`\n    )\n  }\n}\n\nexport function sum(arr) {\n  return arr.reduce((prev, curr) => prev + curr, 0)\n}\n\nfunction makePathArray(obj) {\n  return flattenDeep(obj)\n    .join('.')\n    .replace(/\\[/g, '.')\n    .replace(/\\]/g, '')\n    .split('.')\n}\n\nfunction flattenDeep(arr, newArr = []) {\n  if (!Array.isArray(arr)) {\n    newArr.push(arr)\n  } else {\n    for (let i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], newArr)\n    }\n  }\n  return newArr\n}\n","import { useState, useMemo } from 'react'\n\nexport const defaultState = {}\n\nconst defaultReducer = (old, newState) => newState\n\nexport const useTableState = (\n  initialState = {},\n  overrides = {},\n  { reducer = defaultReducer, useState: userUseState = useState } = {}\n) => {\n  let [state, setState] = userUseState({\n    ...defaultState,\n    ...initialState\n  })\n\n  const overriddenState = useMemo(() => {\n    const newState = {\n      ...state\n    }\n    Object.keys(overrides).forEach(key => {\n      newState[key] = overrides[key]\n    })\n    return newState\n  }, [state, ...Object.values(overrides)])\n\n  const reducedSetState = (updater, type) =>\n    setState(old => {\n      const newState = updater(old)\n      return reducer(old, newState, type)\n    })\n\n  return [overriddenState, reducedSetState]\n}\n","import PropTypes from 'prop-types'\n//\nimport { flexRender, applyHooks, applyPropHooks, mergeProps } from '../utils'\n\nimport { useTableState } from './useTableState'\n\nconst renderErr =\n  'You must specify a render \"type\". This could be \"Header\", \"Filter\", or any other custom renderers you have set on your column.'\n\nconst propTypes = {\n  // General\n  data: PropTypes.array.isRequired,\n  debug: PropTypes.bool\n}\n\nexport const useTable = (props, ...plugins) => {\n  // Validate props\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useTable')\n\n  // Destructure props\n  let { data = [], state: userState, debug } = props\n\n  debug = process.env.NODE_ENV === 'production' ? false : debug\n\n  // Always provide a default state\n  const defaultState = useTableState()\n\n  // But use the users state if provided\n  const state = userState || defaultState\n\n  // These are hooks that plugins can use right before render\n  const hooks = {\n    beforeRender: [],\n    columns: [],\n    headers: [],\n    headerGroups: [],\n    rows: [],\n    row: [],\n    renderableRows: [],\n    getTableProps: [],\n    getRowProps: [],\n    getHeaderRowProps: [],\n    getHeaderProps: [],\n    getCellProps: []\n  }\n\n  // The initial api\n  let api = {\n    ...props,\n    data,\n    state,\n    hooks\n  }\n\n  if (debug) console.time('hooks')\n  // Loop through plugins to build the api out\n  api = plugins.filter(Boolean).reduce((prev, next) => next(prev), api)\n  if (debug) console.timeEnd('hooks')\n\n  // Run the beforeRender hook\n  if (debug) console.time('hooks.beforeRender')\n  applyHooks(api.hooks.beforeRender, undefined, api)\n  if (debug) console.timeEnd('hooks.beforeRender')\n\n  if (debug) console.time('hooks.columns')\n  api.columns = applyHooks(api.hooks.columns, api.columns, api)\n  if (debug) console.timeEnd('hooks.columns')\n\n  if (debug) console.time('hooks.headers')\n  api.headers = applyHooks(api.hooks.headers, api.headers, api)\n  if (debug) console.timeEnd('hooks.headers')\n  ;[...api.columns, ...api.headers].forEach(column => {\n    // Give columns/headers rendering power\n    column.render = (type, userProps = {}) => {\n      if (!type) {\n        throw new Error(renderErr)\n      }\n      return flexRender(column[type], {\n        ...api,\n        ...column,\n        ...userProps\n      })\n    }\n\n    // Give columns/headers getHeaderProps\n    column.getHeaderProps = props =>\n      mergeProps(\n        {\n          key: ['header', column.id].join('_')\n        },\n        applyPropHooks(api.hooks.getHeaderProps, column, api),\n        props\n      )\n  })\n\n  if (debug) console.time('hooks.headerGroups')\n  api.headerGroups = applyHooks(\n    api.hooks.headerGroups,\n    api.headerGroups,\n    api\n  ).filter((headerGroup, i) => {\n    // Filter out any headers and headerGroups that don't have visible columns\n    headerGroup.headers = headerGroup.headers.filter(header => {\n      const recurse = columns =>\n        columns.filter(column => {\n          if (column.columns) {\n            return recurse(column.columns)\n          }\n          return column.visible\n        }).length\n      if (header.columns) {\n        return recurse(header.columns)\n      }\n      return header.visible\n    })\n\n    // Give headerGroups getRowProps\n    if (headerGroup.headers.length) {\n      headerGroup.getRowProps = (props = {}) =>\n        mergeProps(\n          {\n            key: [`header${i}`].join('_')\n          },\n          applyPropHooks(api.hooks.getHeaderRowProps, headerGroup, api),\n          props\n        )\n      return true\n    }\n\n    return false\n  })\n  if (debug) console.timeEnd('hooks.headerGroups')\n\n  // Run the rows (this could be a dangerous hook with a ton of data)\n  if (debug) console.time('hooks.rows')\n  api.rows = applyHooks(api.hooks.rows, api.rows, api)\n  if (debug) console.timeEnd('hooks.rows')\n\n  // This function is absolutely necessary and MUST be called on\n  // any rows the user wishes to be displayed.\n  api.prepareRow = row => {\n    const { index } = row\n    row.getRowProps = props =>\n      mergeProps(\n        { key: ['row', index].join('_') },\n        applyHooks(api.hooks.getRowProps, row, api),\n        props\n      )\n\n    row.cells = row.cells.filter(cell => cell.column.visible)\n\n    row.cells.forEach(cell => {\n      if (!cell) {\n        return\n      }\n\n      const { column } = cell\n\n      cell.getCellProps = props => {\n        const columnPathStr = [index, column.id].join('_')\n        return mergeProps(\n          {\n            key: ['cell', columnPathStr].join('_')\n          },\n          applyPropHooks(api.hooks.getCellProps, cell, api),\n          props\n        )\n      }\n\n      cell.render = (type, userProps = {}) => {\n        if (!type) {\n          throw new Error(\n            'You must specify a render \"type\". This could be \"Cell\", \"Header\", \"Filter\", \"Aggregated\" or any other custom renderers you have set on your column.'\n          )\n        }\n        return flexRender(column[type], {\n          ...api,\n          ...cell,\n          ...userProps\n        })\n      }\n    })\n  }\n\n  api.getTableProps = userProps =>\n    mergeProps(applyPropHooks(api.hooks.getTableProps, api), userProps)\n\n  api.getRowProps = userProps =>\n    mergeProps(applyPropHooks(api.hooks.getRowProps, api), userProps)\n\n  return api\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { getBy } from '../utils'\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      Cell: PropTypes.any,\n      Header: PropTypes.any\n    })\n  )\n}\n\nexport const useColumns = props => {\n  const {\n    debug,\n    columns: userColumns,\n    state: [{ groupBy }]\n  } = props\n\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useColumns')\n\n  const { columns, headerGroups, headers } = useMemo(() => {\n    if (debug) console.info('getColumns')\n\n    // Decorate All the columns\n    let columnTree = decorateColumnTree(userColumns)\n\n    // Get the flat list of all columns\n    let columns = flattenBy(columnTree, 'columns')\n\n    columns = [\n      ...groupBy.map(g => columns.find(col => col.id === g)),\n      ...columns.filter(col => !groupBy.includes(col.id))\n    ]\n\n    // Get headerGroups\n    const headerGroups = makeHeaderGroups(columns, findMaxDepth(columnTree))\n    const headers = flattenBy(headerGroups, 'headers')\n\n    return {\n      columns,\n      headerGroups,\n      headers\n    }\n  }, [groupBy, userColumns])\n\n  return {\n    ...props,\n    columns,\n    headerGroups,\n    headers\n  }\n\n  // Find the depth of the columns\n  function findMaxDepth(columns, depth = 0) {\n    return columns.reduce((prev, curr) => {\n      if (curr.columns) {\n        return Math.max(prev, findMaxDepth(curr.columns, depth + 1))\n      }\n      return depth\n    }, 0)\n  }\n\n  function decorateColumn(column, parent) {\n    // First check for string accessor\n    let { id, accessor, Header } = column\n\n    if (typeof accessor === 'string') {\n      id = id || accessor\n      const accessorString = accessor\n      accessor = row => getBy(row, accessorString)\n    }\n\n    if (!id && typeof Header === 'string') {\n      id = Header\n    }\n\n    if (!id) {\n      // Accessor, but no column id? This is bad.\n      console.error(column)\n      throw new Error('A column id is required!')\n    }\n\n    column = {\n      Header: '',\n      Cell: cell => cell.value,\n      show: true,\n      ...column,\n      id,\n      accessor,\n      parent\n    }\n\n    return column\n  }\n\n  // Build the visible columns, headers and flat column list\n  function decorateColumnTree(columns, parent, depth = 0) {\n    return columns.map(column => {\n      column = decorateColumn(column, parent)\n      if (column.columns) {\n        column.columns = decorateColumnTree(column.columns, column, depth + 1)\n      }\n      return column\n    })\n  }\n\n  function flattenBy(columns, childKey) {\n    const flatColumns = []\n\n    const recurse = columns => {\n      columns.forEach(d => {\n        if (!d[childKey]) {\n          flatColumns.push(d)\n        } else {\n          recurse(d[childKey])\n        }\n      })\n    }\n\n    recurse(columns)\n\n    return flatColumns\n  }\n\n  // Build the header groups from the bottom up\n  function makeHeaderGroups(columns, maxDepth) {\n    const headerGroups = []\n\n    const removeChildColumns = column => {\n      delete column.columns\n      if (column.parent) {\n        removeChildColumns(column.parent)\n      }\n    }\n    columns.forEach(removeChildColumns)\n\n    const buildGroup = (columns, depth = 0) => {\n      const headerGroup = {\n        headers: []\n      }\n\n      const parentColumns = []\n\n      const hasParents = columns.some(col => col.parent)\n\n      columns.forEach(column => {\n        const isFirst = !parentColumns.length\n        let latestParentColumn = [...parentColumns].reverse()[0]\n\n        // If the column has a parent, add it if necessary\n        if (column.parent) {\n          if (isFirst || latestParentColumn.originalID !== column.parent.id) {\n            parentColumns.push({\n              ...column.parent,\n              originalID: column.parent.id,\n              id: [column.parent.id, parentColumns.length].join('_')\n            })\n          }\n        } else if (hasParents) {\n          // If other columns have parents, add a place holder if necessary\n          const placeholderColumn = decorateColumn({\n            originalID: [column.id, 'placeholder', maxDepth - depth].join('_'),\n            id: [\n              column.id,\n              'placeholder',\n              maxDepth - depth,\n              parentColumns.length\n            ].join('_')\n          })\n          if (\n            isFirst ||\n            latestParentColumn.originalID !== placeholderColumn.originalID\n          ) {\n            parentColumns.push(placeholderColumn)\n          }\n        }\n\n        // Establish the new columns[] relationship on the parent\n        if (column.parent || hasParents) {\n          latestParentColumn = [...parentColumns].reverse()[0]\n          latestParentColumn.columns = latestParentColumn.columns || []\n          if (!latestParentColumn.columns.includes(column)) {\n            latestParentColumn.columns.push(column)\n          }\n        }\n\n        headerGroup.headers.push(column)\n      })\n\n      headerGroups.push(headerGroup)\n\n      if (parentColumns.length) {\n        buildGroup(parentColumns)\n      }\n    }\n\n    buildGroup(columns)\n\n    return headerGroups.reverse()\n  }\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nconst propTypes = {\n  subRowsKey: PropTypes.string\n}\n\nexport const useRows = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useRows')\n\n  const { debug, columns, subRowsKey = 'subRows', data } = props\n\n  const accessedRows = useMemo(() => {\n    if (debug) console.info('getAccessedRows')\n\n    // Access the row's data\n    const accessRow = (originalRow, i, depth = 0) => {\n      // Keep the original reference around\n      const original = originalRow\n\n      // Process any subRows\n      const subRows = originalRow[subRowsKey]\n        ? originalRow[subRowsKey].map((d, i) => accessRow(d, i, depth + 1))\n        : undefined\n\n      const row = {\n        original,\n        index: i,\n        subRows,\n        depth\n      }\n\n      // Create the cells and values\n      row.values = {}\n      columns.forEach(column => {\n        row.values[column.id] = column.accessor\n          ? column.accessor(originalRow, i, { subRows, depth, data })\n          : undefined\n      })\n\n      return row\n    }\n\n    // Use the resolved data\n    return data.map((d, i) => accessRow(d, i))\n  }, [data, columns])\n\n  return {\n    ...props,\n    rows: accessedRows\n  }\n}\n","const actions = {}\n\nexport { actions }\n\nexport const addActions = acts => {\n  Object.keys(acts).forEach(key => {\n    actions[key] = acts[key]\n  })\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { getBy, getFirstDefined, setBy } from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.expanded = {}\n\naddActions({\n  toggleExpanded: '__toggleExpanded__',\n  useExpanded: '__useExpanded__'\n})\n\nconst propTypes = {\n  expandedKey: PropTypes.string\n}\n\nexport const useExpanded = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useExpanded')\n\n  const {\n    debug,\n    columns,\n    rows,\n    expandedKey = 'expanded',\n    hooks,\n    state: [{ expanded }, setState]\n  } = props\n\n  const toggleExpandedByPath = (path, set) => {\n    return setState(old => {\n      const { expanded } = old\n      const existing = getBy(expanded, path)\n      set = getFirstDefined(set, !existing)\n      return {\n        ...old,\n        expanded: setBy(expanded, path, set)\n      }\n    }, actions.toggleExpanded)\n  }\n\n  hooks.row.push(row => {\n    const { path } = row\n    row.toggleExpanded = set => toggleExpandedByPath(path, set)\n  })\n\n  const expandedRows = useMemo(() => {\n    if (debug) console.info('getExpandedRows')\n\n    const expandedRows = []\n\n    // Here we do some mutation, but it's the last stage in the\n    // immutable process so this is safe\n    const handleRow = (row, index, depth = 0, parentPath = []) => {\n      // Compute some final state for the row\n      const path = [...parentPath, index]\n\n      row.path = path\n      row.depth = depth\n\n      row.isExpanded =\n        (row.original && row.original[expandedKey]) || getBy(expanded, path)\n\n      row.cells = columns.map(column => {\n        const cell = {\n          column,\n          row,\n          state: null,\n          value: row.values[column.id]\n        }\n\n        return cell\n      })\n\n      expandedRows.push(row)\n\n      if (row.isExpanded && row.subRows && row.subRows.length) {\n        row.subRows.forEach((row, i) => handleRow(row, i, depth + 1, path))\n      }\n    }\n\n    rows.forEach((row, i) => handleRow(row, i))\n\n    return expandedRows\n  }, [rows, expanded, columns])\n\n  const expandedDepth = findExpandedDepth(expanded)\n\n  return {\n    ...props,\n    toggleExpandedByPath,\n    expandedDepth,\n    rows: expandedRows\n  }\n}\n\nfunction findExpandedDepth(obj, depth = 1) {\n  return Object.values(obj).reduce((prev, curr) => {\n    if (typeof curr === 'object') {\n      return Math.max(prev, findExpandedDepth(curr, depth + 1))\n    }\n    return depth\n  }, 0)\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { defaultFilterFn, getFirstDefined } from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.filters = {}\naddActions({\n  setFilter: '__setFilter__',\n  setAllFilters: '__setAllFilters__'\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      filterFn: PropTypes.func,\n      filterAll: PropTypes.bool,\n      canFilter: PropTypes.bool,\n      Filter: PropTypes.any\n    })\n  ),\n\n  filterFn: PropTypes.func,\n  manualFilters: PropTypes.bool\n}\n\nexport const useFilters = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useFilters')\n\n  const {\n    debug,\n    rows,\n    columns,\n    filterFn = defaultFilterFn,\n    manualFilters,\n    disableFilters,\n    hooks,\n    state: [{ filters }, setState]\n  } = props\n\n  columns.forEach(column => {\n    const { id, accessor, canFilter } = column\n    column.canFilter = accessor\n      ? getFirstDefined(\n        canFilter,\n        disableFilters === true ? false : undefined,\n        true\n      )\n      : false\n    // Was going to add this to the filter hook\n    column.filterValue = filters[id]\n  })\n\n  const setFilter = (id, val) => {\n    return setState(old => {\n      if (typeof val === 'undefined') {\n        const { [id]: prev, ...rest } = filters\n        return {\n          ...old,\n          filters: {\n            ...rest\n          }\n        }\n      }\n\n      return {\n        ...old,\n        filters: {\n          ...filters,\n          [id]: val\n        }\n      }\n    }, actions.setFilter)\n  }\n\n  const setAllFilters = filters => {\n    return setState(old => {\n      return {\n        ...old,\n        filters\n      }\n    }, actions.setAllFilters)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      if (column.canFilter) {\n        column.setFilter = val => setFilter(column.id, val)\n      }\n    })\n    return columns\n  })\n\n  const filteredRows = useMemo(() => {\n    if (manualFilters || !Object.keys(filters).length) {\n      return rows\n    }\n\n    if (debug) console.info('getFilteredRows')\n\n    // Filters top level and nested rows\n    const filterRows = rows => {\n      let filteredRows = rows\n\n      filteredRows = Object.entries(filters).reduce(\n        (filteredSoFar, [columnID, filterValue]) => {\n          // Find the filters column\n          const column = columns.find(d => d.id === columnID)\n\n          // Don't filter hidden columns or columns that have had their filters disabled\n          if (!column || column.filterable === false) {\n            return filteredSoFar\n          }\n\n          const filterMethod = column.filterMethod || filterFn\n\n          // If 'filterAll' is set to true, pass the entire dataset to the filter method\n          if (column.filterAll) {\n            return filterMethod(filteredSoFar, columnID, filterValue, column)\n          }\n          return filteredSoFar.filter(row =>\n            filterMethod(row, columnID, filterValue, column)\n          )\n        },\n        rows\n      )\n\n      // Apply the filter to any subRows\n      filteredRows = filteredRows.map(row => {\n        if (!row.subRows) {\n          return row\n        }\n        return {\n          ...row,\n          subRows: filterRows(row.subRows)\n        }\n      })\n\n      // then filter any rows without subcolumns because it would be strange to show\n      filteredRows = filteredRows.filter(row => {\n        if (!row.subRows) {\n          return true\n        }\n        return row.subRows.length > 0\n      })\n\n      return filteredRows\n    }\n\n    return filterRows(rows)\n  }, [rows, filters, manualFilters])\n\n  return {\n    ...props,\n    setFilter,\n    setAllFilters,\n    rows: filteredRows\n  }\n}\n","export function sum(values, rows) {\n  return values.reduce((sum, next) => sum + next, 0)\n}\n\nexport function average(values, rows) {\n  return Math.round((sum(values, rows) / values.length) * 100) / 100\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport * as aggregations from '../aggregations'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\nimport {\n  mergeProps,\n  applyPropHooks,\n  defaultGroupByFn,\n  getFirstDefined\n} from '../utils'\n\ndefaultState.groupBy = []\n\naddActions({\n  toggleGroupBy: '__toggleGroupBy__'\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      aggregate: PropTypes.func,\n      canGroupBy: PropTypes.bool,\n      Aggregated: PropTypes.any\n    })\n  ),\n  groupByFn: PropTypes.func,\n  manualGrouping: PropTypes.bool,\n  aggregations: PropTypes.object\n}\n\nexport const useGroupBy = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useGroupBy')\n\n  const {\n    debug,\n    rows,\n    columns,\n    groupByFn = defaultGroupByFn,\n    manualGroupBy,\n    disableGrouping,\n    aggregations: userAggregations = {},\n    hooks,\n    state: [{ groupBy }, setState]\n  } = props\n\n  columns.forEach(column => {\n    const { id, accessor, canGroupBy } = column\n    column.grouped = groupBy.includes(id)\n\n    column.canGroupBy = accessor\n      ? getFirstDefined(\n        canGroupBy,\n        disableGrouping === true ? false : undefined,\n        true\n      )\n      : false\n\n    column.Aggregated = column.Aggregated || column.Cell\n  })\n\n  const toggleGroupBy = (id, toggle) => {\n    return setState(old => {\n      const resolvedToggle =\n        typeof set !== 'undefined' ? toggle : !groupBy.includes(id)\n      if (resolvedToggle) {\n        return {\n          ...old,\n          groupBy: [...groupBy, id]\n        }\n      }\n      return {\n        ...old,\n        groupBy: groupBy.filter(d => d !== id)\n      }\n    }, actions.toggleGroupBy)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      if (column.canGroupBy) {\n        column.toggleGroupBy = () => toggleGroupBy(column.id)\n      }\n    })\n    return columns\n  })\n\n  hooks.getGroupByToggleProps = []\n\n  const addGroupByToggleProps = (columns, api) => {\n    columns.forEach(column => {\n      const { canGroupBy } = column\n      column.getGroupByToggleProps = props => {\n        return mergeProps(\n          {\n            onClick: canGroupBy\n              ? e => {\n                e.persist()\n                column.toggleGroupBy()\n              }\n              : undefined,\n            style: {\n              cursor: canGroupBy ? 'pointer' : undefined\n            },\n            title: 'Toggle GroupBy'\n          },\n          applyPropHooks(api.hooks.getGroupByToggleProps, column, api),\n          props\n        )\n      }\n    })\n    return columns\n  }\n\n  hooks.columns.push(addGroupByToggleProps)\n  hooks.headers.push(addGroupByToggleProps)\n\n  const groupedRows = useMemo(() => {\n    if (manualGroupBy || !groupBy.length) {\n      return rows\n    }\n    if (debug) console.info('getGroupedRows')\n    // Find the columns that can or are aggregating\n\n    // Uses each column to aggregate rows into a single value\n    const aggregateRowsToValues = rows => {\n      const values = {}\n      columns.forEach(column => {\n        const columnValues = rows.map(d => d.values[column.id])\n        let aggregate =\n          userAggregations[column.aggregate] ||\n          aggregations[column.aggregate] ||\n          column.aggregate\n        if (typeof aggregate === 'function') {\n          values[column.id] = aggregate(columnValues, rows)\n        } else if (aggregate) {\n          throw new Error(\n            `Invalid aggregate \"${aggregate}\" passed to column with ID: \"${\n              column.id\n            }\"`\n          )\n        } else {\n          values[column.id] = columnValues[0]\n        }\n      })\n      return values\n    }\n\n    // Recursively group the data\n    const groupRecursively = (rows, groupBy, depth = 0) => {\n      // This is the last level, just return the rows\n      if (depth >= groupBy.length) {\n        return rows\n      }\n\n      // Group the rows together for this level\n      let groupedRows = Object.entries(groupByFn(rows, groupBy[depth])).map(\n        ([groupByVal, subRows], index) => {\n          // Recurse to sub rows before aggregation\n          subRows = groupRecursively(subRows, groupBy, depth + 1)\n\n          const values = aggregateRowsToValues(subRows)\n\n          const row = {\n            groupByID: groupBy[depth],\n            groupByVal,\n            values,\n            subRows,\n            depth,\n            index\n          }\n          return row\n        }\n      )\n\n      return groupedRows\n    }\n\n    // Assign the new data\n    return groupRecursively(rows, groupBy)\n  }, [rows, groupBy, columns, manualGroupBy])\n\n  return {\n    ...props,\n    rows: groupedRows\n  }\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\nimport {\n  mergeProps,\n  applyPropHooks,\n  getFirstDefined,\n  defaultOrderByFn,\n  defaultSortByFn\n} from '../utils'\n\ndefaultState.sortBy = []\n\naddActions({\n  sortByChange: '__sortByChange__'\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      sortByFn: PropTypes.func,\n      efaultSortDesc: PropTypes.bool\n    })\n  ),\n  sortByFn: PropTypes.func,\n  manualSorting: PropTypes.bool,\n  disableSorting: PropTypes.bool,\n  defaultSortDesc: PropTypes.bool,\n  disableMultiSort: PropTypes.bool\n}\n\nexport const useSortBy = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useSortBy')\n\n  const {\n    debug,\n    rows,\n    columns,\n    orderByFn = defaultOrderByFn,\n    sortByFn = defaultSortByFn,\n    manualSorting,\n    disableSorting,\n    defaultSortDesc,\n    hooks,\n    state: [{ sortBy }, setState]\n  } = props\n\n  columns.forEach(column => {\n    const { accessor, canSortBy } = column\n    column.canSortBy = accessor\n      ? getFirstDefined(\n        canSortBy,\n        disableSorting === true ? false : undefined,\n        true\n      )\n      : false\n  })\n\n  // Updates sorting based on a columnID, desc flag and multi flag\n  const toggleSortByID = (columnID, desc, multi) => {\n    return setState(old => {\n      const { sortBy } = old\n\n      // Find the column for this columnID\n      const column = columns.find(d => d.id === columnID)\n      const resolvedDefaultSortDesc = getFirstDefined(\n        column.defaultSortDesc,\n        defaultSortDesc\n      )\n\n      // Find any existing sortBy for this column\n      const existingSortBy = sortBy.find(d => d.id === columnID)\n      const hasDescDefined = typeof desc !== 'undefined' && desc !== null\n\n      let newSortBy = []\n\n      // What should we do with this filter?\n      let action\n\n      if (!multi) {\n        if (sortBy.length <= 1 && existingSortBy) {\n          if (existingSortBy.desc) {\n            action = 'remove'\n          } else {\n            action = 'toggle'\n          }\n        } else {\n          action = 'replace'\n        }\n      } else {\n        if (!existingSortBy) {\n          action = 'add'\n        } else {\n          if (hasDescDefined) {\n            action = 'set'\n          } else {\n            action = 'toggle'\n          }\n        }\n      }\n\n      if (action === 'replace') {\n        newSortBy = [\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : resolvedDefaultSortDesc\n          }\n        ]\n      } else if (action === 'add') {\n        newSortBy = [\n          ...sortBy,\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : resolvedDefaultSortDesc\n          }\n        ]\n      } else if (action === 'set') {\n        newSortBy = sortBy.map(d => {\n          if (d.id === columnID) {\n            return {\n              ...d,\n              desc\n            }\n          }\n          return d\n        })\n      } else if (action === 'toggle') {\n        newSortBy = sortBy.map(d => {\n          if (d.id === columnID) {\n            return {\n              ...d,\n              desc: !existingSortBy.desc\n            }\n          }\n          return d\n        })\n      } else if (action === 'remove') {\n        newSortBy = []\n      }\n\n      return {\n        ...old,\n        sortBy: newSortBy\n      }\n    }, actions.sortByChange)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      if (column.canSortBy) {\n        column.toggleSortBy = (desc, multi) =>\n          toggleSortByID(column.id, desc, multi)\n      }\n    })\n    return columns\n  })\n\n  hooks.getSortByToggleProps = []\n\n  const addSortByToggleProps = (columns, api) => {\n    columns.forEach(column => {\n      const { canSortBy } = column\n      column.getSortByToggleProps = props => {\n        return mergeProps(\n          {\n            onClick: canSortBy\n              ? e => {\n                e.persist()\n                column.toggleSortBy(\n                  undefined,\n                  !api.disableMultiSort && e.shiftKey\n                )\n              }\n              : undefined,\n            style: {\n              cursor: canSortBy ? 'pointer' : undefined\n            },\n            title: 'Toggle SortBy'\n          },\n          applyPropHooks(api.hooks.getSortByToggleProps, column, api),\n          props\n        )\n      }\n    })\n    return columns\n  }\n\n  hooks.columns.push(addSortByToggleProps)\n  hooks.headers.push(addSortByToggleProps)\n\n  // Mutate columns to reflect sorting state\n  columns.forEach(column => {\n    const { id } = column\n    column.sorted = sortBy.find(d => d.id === id)\n    column.sortedIndex = sortBy.findIndex(d => d.id === id)\n    column.sortedDesc = column.sorted ? column.sorted.desc : undefined\n  })\n\n  const sortedRows = useMemo(() => {\n    if (manualSorting || !sortBy.length) {\n      return rows\n    }\n    if (debug) console.info('getSortedRows')\n\n    const sortMethodsByColumnID = {}\n\n    columns\n      .filter(col => col.sortMethod)\n      .forEach(col => {\n        sortMethodsByColumnID[col.id] = col.sortMethod\n      })\n\n    const sortData = rows => {\n      // Use the orderByFn to compose multiple sortBy's together.\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      const sortedData = orderByFn(\n        rows,\n        sortBy.map(sort => {\n          // Support custom sorting methods for each column\n          const columnSortBy = sortMethodsByColumnID[sort.id]\n\n          // Return the correct sortFn\n          return (a, b) =>\n            (columnSortBy || sortByFn)(\n              a.values[sort.id],\n              b.values[sort.id],\n              sort.desc\n            )\n        }),\n        // Map the directions\n        sortBy.map(d => !d.desc)\n      )\n\n      // TODO: this should be optimized. Not good to loop again\n      sortedData.forEach(row => {\n        if (!row.subRows) {\n          return\n        }\n        row.subRows = sortData(row.subRows)\n      })\n\n      return sortedData\n    }\n\n    return sortData(rows)\n  }, [rows, columns, sortBy, manualSorting])\n\n  return {\n    ...props,\n    rows: sortedRows\n  }\n}\n","import { useMemo, useLayoutEffect } from 'react'\nimport PropTypes from 'prop-types'\n\n//\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.pageSize = 10\ndefaultState.pageIndex = 0\n\naddActions({\n  pageChange: '__pageChange__'\n})\n\nconst propTypes = {\n  // General\n  manualPagination: PropTypes.bool\n}\n\nexport const usePagination = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'usePagination')\n\n  const {\n    rows,\n    manualPagination,\n    debug,\n    state: [\n      {\n        pageSize,\n        pageIndex,\n        pageCount: userPageCount,\n        filters,\n        groupBy,\n        sortBy\n      },\n      setState\n    ]\n  } = props\n\n  useLayoutEffect(() => {\n    setState(\n      old => ({\n        ...old,\n        pageIndex: 0\n      }),\n      actions.pageChange\n    )\n  }, [filters, groupBy, sortBy])\n\n  const { pages, pageCount } = useMemo(() => {\n    if (manualPagination) {\n      return {\n        pages: [rows],\n        pageCount: userPageCount\n      }\n    }\n    if (debug) console.info('getPages')\n\n    // Create a new pages with the first page ready to go.\n    const pages = rows.length ? [] : [[]]\n\n    // Start the pageIndex and currentPage cursors\n    let cursor = 0\n    while (cursor < rows.length) {\n      const end = cursor + pageSize\n      pages.push(rows.slice(cursor, end))\n      cursor = end\n    }\n\n    const pageCount = pages.length\n\n    return {\n      pages,\n      pageCount,\n      pageOptions\n    }\n  }, [rows, pageSize, userPageCount])\n\n  const pageOptions = [...new Array(pageCount)].map((d, i) => i)\n  const page = manualPagination ? rows : pages[pageIndex] || []\n  const canPreviousPage = pageIndex > 0\n  const canNextPage = pageIndex < pageCount - 1\n\n  const gotoPage = pageIndex => {\n    if (debug) console.info('gotoPage')\n    return setState(old => {\n      if (pageIndex < 0 || pageIndex > pageCount - 1) {\n        return old\n      }\n      return {\n        ...old,\n        pageIndex\n      }\n    }, actions.pageChange)\n  }\n\n  const previousPage = () => {\n    return gotoPage(pageIndex - 1)\n  }\n\n  const nextPage = () => {\n    return gotoPage(pageIndex + 1)\n  }\n\n  const setPageSize = pageSize => {\n    setState(old => {\n      const topRowIndex = old.pageSize * old.pageIndex\n      const pageIndex = Math.floor(topRowIndex / pageSize)\n      return {\n        ...old,\n        pageIndex,\n        pageSize\n      }\n    }, actions.setPageSize)\n  }\n\n  return {\n    ...props,\n    pages,\n    pageOptions,\n    page,\n    canPreviousPage,\n    canNextPage,\n    gotoPage,\n    previousPage,\n    nextPage,\n    setPageSize\n  }\n}\n","import PropTypes from 'prop-types'\n\nimport { getFirstDefined, sum } from '../utils'\n\nexport const actions = {}\n\nconst propTypes = {\n  defaultFlex: PropTypes.number\n}\n\nexport const useFlexLayout = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useFlexLayout')\n\n  const {\n    defaultFlex = 1,\n    hooks: {\n      columns: columnsHooks,\n      getRowProps,\n      getHeaderRowProps,\n      getHeaderProps,\n      getCellProps\n    }\n  } = props\n\n  columnsHooks.push((columns, api) => {\n    const visibleColumns = columns.filter(column => {\n      column.visible =\n        typeof column.show === 'function' ? column.show(api) : !!column.show\n      return column.visible\n    })\n\n    const columnMeasurements = {}\n\n    let sumWidth = 0\n    visibleColumns.forEach(column => {\n      const { width, minWidth } = getSizesForColumn(\n        column,\n        defaultFlex,\n        undefined,\n        undefined,\n        api\n      )\n      if (width) {\n        sumWidth += width\n      } else if (minWidth) {\n        sumWidth += minWidth\n      } else {\n        sumWidth += defaultFlex\n      }\n    })\n\n    const rowStyles = {\n      style: {\n        display: 'flex',\n        minWidth: `${sumWidth}px`\n      }\n    }\n\n    api.rowStyles = rowStyles\n\n    getRowProps.push(() => rowStyles)\n    getHeaderRowProps.push(() => rowStyles)\n\n    getHeaderProps.push(column => ({\n      style: {\n        boxSizing: 'border-box',\n        ...getStylesForColumn(column, columnMeasurements, defaultFlex, api)\n      }\n      // [refKey]: el => {\n      //   renderedCellInfoRef.current[key] = {\n      //     column,\n      //     el\n      //   };\n      // },\n    }))\n\n    getCellProps.push(cell => {\n      return {\n        style: {\n          display: 'block',\n          boxSizing: 'border-box',\n          ...getStylesForColumn(\n            cell.column,\n            columnMeasurements,\n            defaultFlex,\n            undefined,\n            api\n          )\n        }\n        // [refKey]: el => {\n        //   renderedCellInfoRef.current[columnPathStr] = {\n        //     column,\n        //     el\n        //   };\n        // }\n      }\n    })\n\n    return columns\n  })\n\n  return props\n}\n\n// Utils\n\nfunction getStylesForColumn(column, columnMeasurements, defaultFlex, api) {\n  const { flex, width, maxWidth } = getSizesForColumn(\n    column,\n    columnMeasurements,\n    defaultFlex,\n    api\n  )\n\n  return {\n    flex: `${flex} 0 auto`,\n    width: `${width}px`,\n    maxWidth: `${maxWidth}px`\n  }\n}\n\nfunction getSizesForColumn(\n  { columns, id, width, minWidth, maxWidth },\n  columnMeasurements,\n  defaultFlex,\n  api\n) {\n  if (columns) {\n    columns = columns\n      .map(column =>\n        getSizesForColumn(column, columnMeasurements, defaultFlex, api)\n      )\n      .filter(Boolean)\n\n    if (!columns.length) {\n      return false\n    }\n\n    const flex = sum(columns.map(col => col.flex))\n    const width = sum(columns.map(col => col.width))\n    const maxWidth = sum(columns.map(col => col.maxWidth))\n\n    return {\n      flex,\n      width,\n      maxWidth\n    }\n  }\n\n  return {\n    flex: width ? 0 : defaultFlex,\n    width:\n      width === 'auto'\n        ? columnMeasurements[id] || defaultFlex\n        : getFirstDefined(width, minWidth, defaultFlex),\n    maxWidth\n  }\n}\n\n// const resetRefs = () => {\n//   if (debug) console.info(\"resetRefs\");\n//   renderedCellInfoRef.current = {};\n// };\n\n// const calculateAutoWidths = () => {\n//   RAF(() => {\n//     const newColumnMeasurements = {};\n//     Object.values(renderedCellInfoRef.current).forEach(({ column, el }) => {\n//       if (!el) {\n//         return;\n//       }\n\n//       let measurement = 0;\n\n//       const measureChildren = children => {\n//         if (children) {\n//           [].slice.call(children).forEach(child => {\n//             measurement = Math.max(\n//               measurement,\n//               Math.ceil(child.offsetWidth) || 0\n//             );\n//             measureChildren(child.children);\n//           });\n//         }\n//         return measurement;\n//       };\n\n//       const parentDims = getElementDimensions(el);\n//       measureChildren(el.children);\n\n//       newColumnMeasurements[column.id] = Math.max(\n//         newColumnMeasurements[column.id] || 0,\n//         measurement + parentDims.paddingLeft + parentDims.paddingRight\n//       );\n//     });\n\n//     const oldKeys = Object.keys(columnMeasurements);\n//     const newKeys = Object.keys(newColumnMeasurements);\n\n//     const needsUpdate =\n//       oldKeys.length !== newKeys.length ||\n//       oldKeys.some(key => {\n//         return columnMeasurements[key] !== newColumnMeasurements[key];\n//       });\n\n//     if (needsUpdate) {\n//       setState(old => {\n//         return {\n//           ...old,\n//           columnMeasurements: newColumnMeasurements\n//         };\n//       }, actions.updateAutoWidth);\n//     }\n//   });\n// };\n","import { useState } from 'react'\n\n// Token pagination behaves a bit differently from\n// index based pagination. This hook aids in that process.\n\nexport const useTokenPagination = () => {\n  const [pageToken, setPageToken] = useState()\n  const [nextPageToken, setNextPageToken] = useState()\n  const [previousPageTokens, setPreviousPageTokens] = useState([])\n  const [pageIndex, setPageIndex] = useState(0)\n\n  // Since we're using pagination tokens intead of index, we need\n  // to be a bit clever with page-like navigation here.\n  const nextPage = () => {\n    setPageIndex(old => old + 1)\n    setPreviousPageTokens(old => [...old, pageToken])\n    setPageToken(nextPageToken)\n  }\n\n  const previousPage = () => {\n    setPageIndex(old => old - 1)\n    setPreviousPageTokens(old =>\n      [...old]\n        .reverse()\n        .slice(1)\n        .reverse()\n    )\n    setPageToken(previousPageTokens[previousPageTokens.length - 1])\n  }\n\n  const resetPagination = () => {\n    setPageToken(undefined)\n    setPageIndex(0)\n    setNextPageToken(undefined)\n    setPreviousPageTokens([])\n  }\n\n  const canPreviousPage = previousPageTokens.length\n  const canNextPage = nextPageToken\n\n  return {\n    setNextPageToken,\n    pageToken,\n    pageIndex,\n    previousPage,\n    nextPage,\n    canPreviousPage,\n    canNextPage,\n    resetPagination\n  }\n}\n"],"names":["getBy","obj","path","def","val","pathObj","makePathArray","reduce","cursor","pathPart","e","defaultOrderByFn","arr","funcs","dirs","_toConsumableArray","sort","rowA","rowB","i","length","sortFn","desc","sortInt","index","defaultSortByFn","a","b","toLowerCase","getFirstDefined","arguments","defaultGroupByFn","rows","grouper","prev","row","resKey","values","Array","isArray","push","defaultFilterFn","id","value","column","undefined","String","includes","setBy","recurse","depth","key","target","_typeof","flexRender","Comp","props","Object","getPrototypeOf","isReactComponent","React","mergeProps","groups","forEach","style","className","rest","filter","Boolean","join","applyHooks","hooks","initial","args","next","applyPropHooks","sum","curr","flattenDeep","replace","split","newArr","defaultState","defaultReducer","old","newState","useTableState","initialState","overrides","reducer","useState","state","setState","useMemo","keys","updater","type","renderErr","propTypes","data","PropTypes","array","isRequired","debug","bool","useTable","checkPropTypes","userState","process","env","NODE_ENV","api","beforeRender","columns","headers","headerGroups","renderableRows","getTableProps","getRowProps","getHeaderRowProps","getHeaderProps","getCellProps","console","time","plugins","timeEnd","render","userProps","Error","headerGroup","header","visible","prepareRow","cells","cell","columnPathStr","arrayOf","shape","Cell","any","Header","useColumns","userColumns","groupBy","info","columnTree","decorateColumnTree","parent","map","decorateColumn","flattenBy","maxDepth","removeChildColumns","buildGroup","parentColumns","hasParents","some","col","isFirst","latestParentColumn","reverse","originalID","placeholderColumn","makeHeaderGroups","g","find","findMaxDepth","Math","max","accessor","accessorString","error","show","childKey","flatColumns","d","subRowsKey","string","useRows","accessRow","originalRow","original","subRows","actions","addActions","acts","expanded","toggleExpanded","useExpanded","expandedKey","toggleExpandedByPath","set","existing","expandedRows","handleRow","parentPath","isExpanded","expandedDepth","findExpandedDepth","filters","setFilter","setAllFilters","filterFn","func","filterAll","canFilter","Filter","manualFilters","useFilters","disableFilters","filterValue","filteredRows","filterRows","entries","filteredSoFar","columnID","filterable","filterMethod","average","round","toggleGroupBy","aggregate","canGroupBy","Aggregated","groupByFn","manualGrouping","aggregations","object","useGroupBy","manualGroupBy","disableGrouping","userAggregations","grouped","toggle","getGroupByToggleProps","addGroupByToggleProps","onClick","persist","title","groupRecursively","groupByVal","columnValues","groupByID","sortBy","sortByChange","sortByFn","efaultSortDesc","manualSorting","disableSorting","defaultSortDesc","disableMultiSort","useSortBy","orderByFn","canSortBy","toggleSortBy","multi","action","resolvedDefaultSortDesc","existingSortBy","hasDescDefined","newSortBy","getSortByToggleProps","addSortByToggleProps","shiftKey","sorted","sortedIndex","findIndex","sortedDesc","sortMethodsByColumnID","sortMethod","sortData","sortedData","columnSortBy","pageSize","pageIndex","pageChange","manualPagination","usePagination","userPageCount","pageCount","useLayoutEffect","pages","end","slice","pageOptions","page","gotoPage","canPreviousPage","canNextPage","previousPage","nextPage","setPageSize","topRowIndex","floor","defaultFlex","number","useFlexLayout","columnsHooks","visibleColumns","columnMeasurements","sumWidth","getSizesForColumn","width","minWidth","rowStyles","display","boxSizing","getStylesForColumn","flex","maxWidth","useTokenPagination","pageToken","setPageToken","nextPageToken","setNextPageToken","previousPageTokens","setPreviousPageTokens","setPageIndex","resetPagination"],"mappings":"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"}