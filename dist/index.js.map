{"version":3,"file":"index.js","sources":["../src/utils.js","../src/hooks/useTableState.js","../src/hooks/useTable.js","../src/hooks/useColumns.js","../src/hooks/useRows.js","../src/actions.js","../src/hooks/useExpanded.js","../src/hooks/useFilters.js","../src/aggregations.js","../src/hooks/useGroupBy.js","../src/hooks/useSortBy.js","../src/hooks/usePagination.js","../src/hooks/useFlexLayout.js","../src/hooks/useTokenPagination.js"],"sourcesContent":["import React from 'react'\n\nexport function getBy(obj, path, def) {\n  if (!path) {\n    return obj\n  }\n  const pathObj = makePathArray(path)\n  let val\n  try {\n    val = pathObj.reduce((cursor, pathPart) => cursor[pathPart], obj)\n  } catch (e) {\n    // continue regardless of error\n  }\n  return typeof val !== 'undefined' ? val : def\n}\n\nexport function defaultOrderByFn(arr, funcs, dirs) {\n  return [...arr].sort((rowA, rowB) => {\n    for (let i = 0; i < funcs.length; i += 1) {\n      const sortFn = funcs[i]\n      const desc = dirs[i] === false || dirs[i] === 'desc'\n      const sortInt = sortFn(rowA, rowB)\n      if (sortInt !== 0) {\n        return desc ? -sortInt : sortInt\n      }\n    }\n    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index\n  })\n}\n\nexport function defaultSortByFn(a, b, desc) {\n  // force null and undefined to the bottom\n  a = a === null || a === undefined ? '' : a\n  b = b === null || b === undefined ? '' : b\n  // force any string values to lowercase\n  a = typeof a === 'string' ? a.toLowerCase() : a\n  b = typeof b === 'string' ? b.toLowerCase() : b\n  // Return either 1 or -1 to indicate a sort priority\n  if (a > b) {\n    return 1\n  }\n  if (a < b) {\n    return -1\n  }\n  // returning 0, undefined or any falsey value will defer to the next\n  // sorting mechanism or eventually the columns index via the orderByFn\n  return 0\n}\n\nexport function getFirstDefined(...args) {\n  for (let i = 0; i < args.length; i += 1) {\n    if (typeof args[i] !== 'undefined') {\n      return args[i]\n    }\n  }\n}\n\nexport function defaultGroupByFn(rows, grouper) {\n  return rows.reduce((prev, row, i) => {\n    const resKey =\n      typeof grouper === 'function'\n        ? grouper(row.values, i)\n        : row.values[grouper]\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : []\n    prev[resKey].push(row)\n    return prev\n  }, {})\n}\n\nexport function defaultFilterFn(row, id, value, column) {\n  return row.values[id] !== undefined\n    ? String(row.values[id])\n      .toLowerCase()\n      .includes(String(value).toLowerCase())\n    : true\n}\n\nexport function setBy(obj = {}, path, value) {\n  const recurse = (obj, depth = 0) => {\n    const key = path[depth]\n    const target = typeof obj[key] !== 'object' ? {} : obj[key]\n    const subValue =\n      depth === path.length - 1 ? value : recurse(target, depth + 1)\n    return {\n      ...obj,\n      [key]: subValue\n    }\n  }\n\n  return recurse(obj)\n}\n\nexport function getElementDimensions(element) {\n  const rect = element.getBoundingClientRect()\n  const style = window.getComputedStyle(element)\n  const margins = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight)\n  }\n  const padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight)\n  }\n  return {\n    left: Math.ceil(rect.left),\n    width: Math.ceil(rect.width),\n    outerWidth: Math.ceil(\n      rect.width + margins.left + margins.right + padding.left + padding.right\n    ),\n    marginLeft: margins.left,\n    marginRight: margins.right,\n    paddingLeft: padding.left,\n    paddingRight: padding.right,\n    scrollWidth: element.scrollWidth\n  }\n}\n\nexport function flexRender(Comp, props) {\n  if (typeof Comp === 'function') {\n    return Object.getPrototypeOf(Comp).isReactComponent ? (\n      <Comp {...props} />\n    ) : (\n      Comp(props)\n    )\n  }\n  return Comp\n}\n\nexport const mergeProps = (...groups) => {\n  let props = {}\n  groups.forEach(({ style = {}, className, ...rest } = {}) => {\n    props = {\n      ...props,\n      ...rest,\n      style: {\n        ...(props.style || {}),\n        ...style\n      },\n      className: [props.className, className].filter(Boolean).join(' ')\n    }\n  })\n  return props\n}\n\nexport const applyHooks = (hooks, initial, ...args) =>\n  hooks.reduce((prev, next) => next(prev, ...args), initial)\n\nexport const applyPropHooks = (hooks, ...args) =>\n  hooks.reduce((prev, next) => mergeProps(prev, next(...args)), {})\n\nexport const warnUnknownProps = props => {\n  if (Object.keys(props).length) {\n    throw new Error(\n      `Unknown options passed to useReactTable:\n      \n${JSON.stringify(props, null, 2)}`\n    )\n  }\n}\n\nexport function sum(arr) {\n  return arr.reduce((prev, curr) => prev + curr, 0)\n}\n\nfunction makePathArray(obj) {\n  return flattenDeep(obj)\n    .join('.')\n    .replace(/\\[/g, '.')\n    .replace(/\\]/g, '')\n    .split('.')\n}\n\nfunction flattenDeep(arr, newArr = []) {\n  if (!Array.isArray(arr)) {\n    newArr.push(arr)\n  } else {\n    for (let i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], newArr)\n    }\n  }\n  return newArr\n}\n","import { useState, useMemo } from 'react'\n\nexport const defaultState = {}\n\nconst defaultReducer = (old, newState) => newState\n\nexport const useTableState = (\n  initialState = {},\n  overrides = {},\n  { reducer = defaultReducer, useState: userUseState = useState } = {}\n) => {\n  let [state, setState] = userUseState({\n    ...defaultState,\n    ...initialState\n  })\n\n  const overriddenState = useMemo(() => {\n    const newState = {\n      ...state\n    }\n    Object.keys(overrides).forEach(key => {\n      newState[key] = overrides[key]\n    })\n    return newState\n  }, [state, ...Object.values(overrides)])\n\n  const reducedSetState = (updater, type) =>\n    setState(old => {\n      const newState = updater(old)\n      return reducer(old, newState, type)\n    })\n\n  return [overriddenState, reducedSetState]\n}\n","import PropTypes from 'prop-types'\n//\nimport { flexRender, applyHooks, applyPropHooks, mergeProps } from '../utils'\n\nimport { useTableState } from './useTableState'\n\nconst renderErr =\n  'You must specify a render \"type\". This could be \"Header\", \"Filter\", or any other custom renderers you have set on your column.'\n\nconst propTypes = {\n  // General\n  data: PropTypes.array.isRequired,\n  debug: PropTypes.bool\n}\n\nexport const useTable = (props, ...plugins) => {\n  // Validate props\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useTable')\n\n  // Destructure props\n  let { data = [], state: userState, debug } = props\n\n  debug = process.env.NODE_ENV === 'production' ? false : debug\n\n  // Always provide a default state\n  const defaultState = useTableState()\n\n  // But use the users state if provided\n  const state = userState || defaultState\n\n  // These are hooks that plugins can use right before render\n  const hooks = {\n    beforeRender: [],\n    columns: [],\n    headers: [],\n    headerGroups: [],\n    rows: [],\n    row: [],\n    renderableRows: [],\n    getTableProps: [],\n    getRowProps: [],\n    getHeaderRowProps: [],\n    getHeaderProps: [],\n    getCellProps: []\n  }\n\n  // The initial api\n  let api = {\n    ...props,\n    data,\n    state,\n    hooks\n  }\n\n  if (debug) console.time('hooks')\n  // Loop through plugins to build the api out\n  api = plugins.filter(Boolean).reduce((prev, next) => next(prev), api)\n  if (debug) console.timeEnd('hooks')\n\n  // Run the beforeRender hook\n  if (debug) console.time('hooks.beforeRender')\n  applyHooks(api.hooks.beforeRender, undefined, api)\n  if (debug) console.timeEnd('hooks.beforeRender')\n\n  if (debug) console.time('hooks.columns')\n  api.columns = applyHooks(api.hooks.columns, api.columns, api)\n  if (debug) console.timeEnd('hooks.columns')\n\n  if (debug) console.time('hooks.headers')\n  api.headers = applyHooks(api.hooks.headers, api.headers, api)\n  if (debug) console.timeEnd('hooks.headers')\n  ;[...api.columns, ...api.headers].forEach(column => {\n    // Give columns/headers rendering power\n    column.render = (type, userProps = {}) => {\n      if (!type) {\n        throw new Error(renderErr)\n      }\n      return flexRender(column[type], {\n        ...api,\n        ...column,\n        ...userProps\n      })\n    }\n\n    // Give columns/headers getHeaderProps\n    column.getHeaderProps = props =>\n      mergeProps(\n        {\n          key: ['header', column.id].join('_')\n        },\n        applyPropHooks(api.hooks.getHeaderProps, column, api),\n        props\n      )\n  })\n\n  if (debug) console.time('hooks.headerGroups')\n  api.headerGroups = applyHooks(\n    api.hooks.headerGroups,\n    api.headerGroups,\n    api\n  ).filter((headerGroup, i) => {\n    // Filter out any headers and headerGroups that don't have visible columns\n    headerGroup.headers = headerGroup.headers.filter(header => {\n      const recurse = columns =>\n        columns.filter(column => {\n          if (column.columns) {\n            return recurse(column.columns)\n          }\n          return column.visible\n        }).length\n      if (header.columns) {\n        return recurse(header.columns)\n      }\n      return header.visible\n    })\n\n    // Give headerGroups getRowProps\n    if (headerGroup.headers.length) {\n      headerGroup.getRowProps = (props = {}) =>\n        mergeProps(\n          {\n            key: [`header${i}`].join('_')\n          },\n          applyPropHooks(api.hooks.getHeaderRowProps, headerGroup, api),\n          props\n        )\n      return true\n    }\n\n    return false\n  })\n  if (debug) console.timeEnd('hooks.headerGroups')\n\n  // Run the rows (this could be a dangerous hook with a ton of data)\n  if (debug) console.time('hooks.rows')\n  api.rows = applyHooks(api.hooks.rows, api.rows, api)\n  if (debug) console.timeEnd('hooks.rows')\n\n  // The prepareRow function is absolutely necessary and MUST be called on\n  // any rows the user wishes to be displayed.\n\n  api.prepareRow = row => {\n    const { path } = row\n    row.getRowProps = props =>\n      mergeProps(\n        { key: ['row', path].join('_') },\n        applyHooks(api.hooks.getRowProps, row, api),\n        props\n      )\n\n    // need to apply any row specific hooks (useExpanded requires this)\n    applyHooks(api.hooks.row, row, api)\n\n    const visibleColumns = api.columns.filter(column => column.visible)\n\n    // Build the cells for each row\n    row.cells = visibleColumns.map(column => {\n      const cell = {\n        column,\n        row,\n        value: row.values[column.id]\n      }\n\n      cell.getCellProps = props => {\n        const columnPathStr = [path, column.id].join('_')\n        return mergeProps(\n          {\n            key: ['cell', columnPathStr].join('_')\n          },\n          applyPropHooks(api.hooks.getCellProps, cell, api),\n          props\n        )\n      }\n\n      cell.render = (type, userProps = {}) => {\n        if (!type) {\n          throw new Error(\n            'You must specify a render \"type\". This could be \"Cell\", \"Header\", \"Filter\", \"Aggregated\" or any other custom renderers you have set on your column.'\n          )\n        }\n        return flexRender(column[type], {\n          ...api,\n          ...cell,\n          ...userProps\n        })\n      }\n\n      return cell\n    })\n  }\n\n  api.getTableProps = userProps =>\n    mergeProps(applyPropHooks(api.hooks.getTableProps, api), userProps)\n\n  api.getRowProps = userProps =>\n    mergeProps(applyPropHooks(api.hooks.getRowProps, api), userProps)\n\n  return api\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { getBy } from '../utils'\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      Cell: PropTypes.any,\n      Header: PropTypes.any\n    })\n  )\n}\n\nexport const useColumns = props => {\n  const {\n    debug,\n    columns: userColumns,\n    state: [{ groupBy }]\n  } = props\n\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useColumns')\n\n  const { columns, headerGroups, headers } = useMemo(() => {\n    if (debug) console.info('getColumns')\n\n    // Decorate All the columns\n    let columnTree = decorateColumnTree(userColumns)\n\n    // Get the flat list of all columns\n    let columns = flattenBy(columnTree, 'columns')\n\n    columns = [\n      ...groupBy.map(g => columns.find(col => col.id === g)),\n      ...columns.filter(col => !groupBy.includes(col.id))\n    ]\n\n    // Get headerGroups\n    const headerGroups = makeHeaderGroups(columns, findMaxDepth(columnTree))\n    const headers = flattenBy(headerGroups, 'headers')\n\n    return {\n      columns,\n      headerGroups,\n      headers\n    }\n  }, [groupBy, userColumns])\n\n  return {\n    ...props,\n    columns,\n    headerGroups,\n    headers\n  }\n\n  // Find the depth of the columns\n  function findMaxDepth(columns, depth = 0) {\n    return columns.reduce((prev, curr) => {\n      if (curr.columns) {\n        return Math.max(prev, findMaxDepth(curr.columns, depth + 1))\n      }\n      return depth\n    }, 0)\n  }\n\n  function decorateColumn(column, parent) {\n    // First check for string accessor\n    let { id, accessor, Header } = column\n\n    if (typeof accessor === 'string') {\n      id = id || accessor\n      const accessorString = accessor\n      accessor = row => getBy(row, accessorString)\n    }\n\n    if (!id && typeof Header === 'string') {\n      id = Header\n    }\n\n    if (!id) {\n      // Accessor, but no column id? This is bad.\n      console.error(column)\n      throw new Error('A column id is required!')\n    }\n\n    column = {\n      Header: '',\n      Cell: cell => cell.value,\n      show: true,\n      ...column,\n      id,\n      accessor,\n      parent\n    }\n\n    return column\n  }\n\n  // Build the visible columns, headers and flat column list\n  function decorateColumnTree(columns, parent, depth = 0) {\n    return columns.map(column => {\n      column = decorateColumn(column, parent)\n      if (column.columns) {\n        column.columns = decorateColumnTree(column.columns, column, depth + 1)\n      }\n      return column\n    })\n  }\n\n  function flattenBy(columns, childKey) {\n    const flatColumns = []\n\n    const recurse = columns => {\n      columns.forEach(d => {\n        if (!d[childKey]) {\n          flatColumns.push(d)\n        } else {\n          recurse(d[childKey])\n        }\n      })\n    }\n\n    recurse(columns)\n\n    return flatColumns\n  }\n\n  // Build the header groups from the bottom up\n  function makeHeaderGroups(columns, maxDepth) {\n    const headerGroups = []\n\n    const removeChildColumns = column => {\n      delete column.columns\n      if (column.parent) {\n        removeChildColumns(column.parent)\n      }\n    }\n    columns.forEach(removeChildColumns)\n\n    const buildGroup = (columns, depth = 0) => {\n      const headerGroup = {\n        headers: []\n      }\n\n      const parentColumns = []\n\n      const hasParents = columns.some(col => col.parent)\n\n      columns.forEach(column => {\n        const isFirst = !parentColumns.length\n        let latestParentColumn = [...parentColumns].reverse()[0]\n\n        // If the column has a parent, add it if necessary\n        if (column.parent) {\n          if (isFirst || latestParentColumn.originalID !== column.parent.id) {\n            parentColumns.push({\n              ...column.parent,\n              originalID: column.parent.id,\n              id: [column.parent.id, parentColumns.length].join('_')\n            })\n          }\n        } else if (hasParents) {\n          // If other columns have parents, add a place holder if necessary\n          const placeholderColumn = decorateColumn({\n            originalID: [column.id, 'placeholder', maxDepth - depth].join('_'),\n            id: [\n              column.id,\n              'placeholder',\n              maxDepth - depth,\n              parentColumns.length\n            ].join('_')\n          })\n          if (\n            isFirst ||\n            latestParentColumn.originalID !== placeholderColumn.originalID\n          ) {\n            parentColumns.push(placeholderColumn)\n          }\n        }\n\n        // Establish the new columns[] relationship on the parent\n        if (column.parent || hasParents) {\n          latestParentColumn = [...parentColumns].reverse()[0]\n          latestParentColumn.columns = latestParentColumn.columns || []\n          if (!latestParentColumn.columns.includes(column)) {\n            latestParentColumn.columns.push(column)\n          }\n        }\n\n        headerGroup.headers.push(column)\n      })\n\n      headerGroups.push(headerGroup)\n\n      if (parentColumns.length) {\n        buildGroup(parentColumns)\n      }\n    }\n\n    buildGroup(columns)\n\n    return headerGroups.reverse()\n  }\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nconst propTypes = {\n  subRowsKey: PropTypes.string\n}\n\nexport const useRows = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useRows')\n\n  const { debug, columns, subRowsKey = 'subRows', data } = props\n\n  const accessedRows = useMemo(() => {\n    if (debug) console.info('getAccessedRows')\n\n    // Access the row's data\n    const accessRow = (originalRow, i, depth = 0) => {\n      // Keep the original reference around\n      const original = originalRow\n\n      // Process any subRows\n      const subRows = originalRow[subRowsKey]\n        ? originalRow[subRowsKey].map((d, i) => accessRow(d, i, depth + 1))\n        : undefined\n\n      const row = {\n        original,\n        index: i,\n        subRows,\n        depth,\n        cells: [{}] // This is a dummy cell\n      }\n\n      // Override common array functions (and the dummy cell's getCellProps function)\n      // to show an error if it is accessed without calling prepareRow\n      const unpreparedAccessWarning = () => {\n        throw new Error(\n          'React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.'\n        )\n      }\n      row.cells.map = unpreparedAccessWarning\n      row.cells.filter = unpreparedAccessWarning\n      row.cells.forEach = unpreparedAccessWarning\n      row.cells[0].getCellProps = unpreparedAccessWarning\n\n      // Create the cells and values\n      row.values = {}\n      columns.forEach(column => {\n        row.values[column.id] = column.accessor\n          ? column.accessor(originalRow, i, { subRows, depth, data })\n          : undefined\n      })\n\n      return row\n    }\n\n    // Use the resolved data\n    return data.map((d, i) => accessRow(d, i))\n  }, [data, columns])\n\n  return {\n    ...props,\n    rows: accessedRows\n  }\n}\n","const actions = {}\n\nexport { actions }\n\nexport const addActions = acts => {\n  Object.keys(acts).forEach(key => {\n    actions[key] = acts[key]\n  })\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { getBy, getFirstDefined, setBy } from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.expanded = {}\n\naddActions({\n  toggleExpanded: '__toggleExpanded__',\n  useExpanded: '__useExpanded__'\n})\n\nconst propTypes = {\n  expandedKey: PropTypes.string\n}\n\nexport const useExpanded = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useExpanded')\n\n  const {\n    debug,\n    columns,\n    rows,\n    expandedKey = 'expanded',\n    hooks,\n    state: [{ expanded }, setState]\n  } = props\n\n  const toggleExpandedByPath = (path, set) => {\n    return setState(old => {\n      const { expanded } = old\n      const existing = getBy(expanded, path)\n      set = getFirstDefined(set, !existing)\n      return {\n        ...old,\n        expanded: setBy(expanded, path, set)\n      }\n    }, actions.toggleExpanded)\n  }\n\n  hooks.row.push(row => {\n    const { path } = row\n    row.toggleExpanded = set => toggleExpandedByPath(path, set)\n  })\n\n  const expandedRows = useMemo(() => {\n    if (debug) console.info('getExpandedRows')\n\n    const expandedRows = []\n\n    // Here we do some mutation, but it's the last stage in the\n    // immutable process so this is safe\n    const handleRow = (row, index, depth = 0, parentPath = []) => {\n      // Compute some final state for the row\n      const path = [...parentPath, index]\n\n      row.path = path\n      row.depth = depth\n\n      row.isExpanded =\n        (row.original && row.original[expandedKey]) || getBy(expanded, path)\n\n      expandedRows.push(row)\n\n      if (row.isExpanded && row.subRows && row.subRows.length) {\n        row.subRows.forEach((row, i) => handleRow(row, i, depth + 1, path))\n      }\n    }\n\n    rows.forEach((row, i) => handleRow(row, i))\n\n    return expandedRows\n  }, [rows, expanded, columns])\n\n  const expandedDepth = findExpandedDepth(expanded)\n\n  return {\n    ...props,\n    toggleExpandedByPath,\n    expandedDepth,\n    rows: expandedRows\n  }\n}\n\nfunction findExpandedDepth(obj, depth = 1) {\n  return Object.values(obj).reduce((prev, curr) => {\n    if (typeof curr === 'object') {\n      return Math.max(prev, findExpandedDepth(curr, depth + 1))\n    }\n    return depth\n  }, 0)\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { defaultFilterFn, getFirstDefined } from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.filters = {}\naddActions({\n  setFilter: '__setFilter__',\n  setAllFilters: '__setAllFilters__'\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      filterFn: PropTypes.func,\n      filterAll: PropTypes.bool,\n      canFilter: PropTypes.bool,\n      Filter: PropTypes.any\n    })\n  ),\n\n  filterFn: PropTypes.func,\n  manualFilters: PropTypes.bool\n}\n\nexport const useFilters = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useFilters')\n\n  const {\n    debug,\n    rows,\n    columns,\n    filterFn = defaultFilterFn,\n    manualFilters,\n    disableFilters,\n    hooks,\n    state: [{ filters }, setState]\n  } = props\n\n  columns.forEach(column => {\n    const { id, accessor, canFilter } = column\n    column.canFilter = accessor\n      ? getFirstDefined(\n        canFilter,\n        disableFilters === true ? false : undefined,\n        true\n      )\n      : false\n    // Was going to add this to the filter hook\n    column.filterValue = filters[id]\n  })\n\n  const setFilter = (id, val) => {\n    return setState(old => {\n      if (typeof val === 'undefined') {\n        const { [id]: prev, ...rest } = filters\n        return {\n          ...old,\n          filters: {\n            ...rest\n          }\n        }\n      }\n\n      return {\n        ...old,\n        filters: {\n          ...filters,\n          [id]: val\n        }\n      }\n    }, actions.setFilter)\n  }\n\n  const setAllFilters = filters => {\n    return setState(old => {\n      return {\n        ...old,\n        filters\n      }\n    }, actions.setAllFilters)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      if (column.canFilter) {\n        column.setFilter = val => setFilter(column.id, val)\n      }\n    })\n    return columns\n  })\n\n  const filteredRows = useMemo(() => {\n    if (manualFilters || !Object.keys(filters).length) {\n      return rows\n    }\n\n    if (debug) console.info('getFilteredRows')\n\n    // Filters top level and nested rows\n    const filterRows = rows => {\n      let filteredRows = rows\n\n      filteredRows = Object.entries(filters).reduce(\n        (filteredSoFar, [columnID, filterValue]) => {\n          // Find the filters column\n          const column = columns.find(d => d.id === columnID)\n\n          // Don't filter hidden columns or columns that have had their filters disabled\n          if (!column || column.filterable === false) {\n            return filteredSoFar\n          }\n\n          const filterMethod = column.filterMethod || filterFn\n\n          // If 'filterAll' is set to true, pass the entire dataset to the filter method\n          if (column.filterAll) {\n            return filterMethod(filteredSoFar, columnID, filterValue, column)\n          }\n          return filteredSoFar.filter(row =>\n            filterMethod(row, columnID, filterValue, column)\n          )\n        },\n        rows\n      )\n\n      // Apply the filter to any subRows\n      filteredRows = filteredRows.map(row => {\n        if (!row.subRows) {\n          return row\n        }\n        return {\n          ...row,\n          subRows: filterRows(row.subRows)\n        }\n      })\n\n      // then filter any rows without subcolumns because it would be strange to show\n      filteredRows = filteredRows.filter(row => {\n        if (!row.subRows) {\n          return true\n        }\n        return row.subRows.length > 0\n      })\n\n      return filteredRows\n    }\n\n    return filterRows(rows)\n  }, [rows, filters, manualFilters])\n\n  return {\n    ...props,\n    setFilter,\n    setAllFilters,\n    rows: filteredRows\n  }\n}\n","export function sum(values, rows) {\n  return values.reduce((sum, next) => sum + next, 0)\n}\n\nexport function average(values, rows) {\n  return Math.round((sum(values, rows) / values.length) * 100) / 100\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport * as aggregations from '../aggregations'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\nimport {\n  mergeProps,\n  applyPropHooks,\n  defaultGroupByFn,\n  getFirstDefined\n} from '../utils'\n\ndefaultState.groupBy = []\n\naddActions({\n  toggleGroupBy: '__toggleGroupBy__'\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      aggregate: PropTypes.func,\n      canGroupBy: PropTypes.bool,\n      Aggregated: PropTypes.any\n    })\n  ),\n  groupByFn: PropTypes.func,\n  manualGrouping: PropTypes.bool,\n  aggregations: PropTypes.object\n}\n\nexport const useGroupBy = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useGroupBy')\n\n  const {\n    debug,\n    rows,\n    columns,\n    groupByFn = defaultGroupByFn,\n    manualGroupBy,\n    disableGrouping,\n    aggregations: userAggregations = {},\n    hooks,\n    state: [{ groupBy }, setState]\n  } = props\n\n  columns.forEach(column => {\n    const { id, accessor, canGroupBy } = column\n    column.grouped = groupBy.includes(id)\n\n    column.canGroupBy = accessor\n      ? getFirstDefined(\n        canGroupBy,\n        disableGrouping === true ? false : undefined,\n        true\n      )\n      : false\n\n    column.Aggregated = column.Aggregated || column.Cell\n  })\n\n  const toggleGroupBy = (id, toggle) => {\n    return setState(old => {\n      const resolvedToggle =\n        typeof toggle !== 'undefined' ? toggle : !groupBy.includes(id)\n      if (resolvedToggle) {\n        return {\n          ...old,\n          groupBy: [...groupBy, id]\n        }\n      }\n      return {\n        ...old,\n        groupBy: groupBy.filter(d => d !== id)\n      }\n    }, actions.toggleGroupBy)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      if (column.canGroupBy) {\n        column.toggleGroupBy = () => toggleGroupBy(column.id)\n      }\n    })\n    return columns\n  })\n\n  hooks.getGroupByToggleProps = []\n\n  const addGroupByToggleProps = (columns, api) => {\n    columns.forEach(column => {\n      const { canGroupBy } = column\n      column.getGroupByToggleProps = props => {\n        return mergeProps(\n          {\n            onClick: canGroupBy\n              ? e => {\n                e.persist()\n                column.toggleGroupBy()\n              }\n              : undefined,\n            style: {\n              cursor: canGroupBy ? 'pointer' : undefined\n            },\n            title: 'Toggle GroupBy'\n          },\n          applyPropHooks(api.hooks.getGroupByToggleProps, column, api),\n          props\n        )\n      }\n    })\n    return columns\n  }\n\n  hooks.columns.push(addGroupByToggleProps)\n  hooks.headers.push(addGroupByToggleProps)\n\n  const groupedRows = useMemo(() => {\n    if (manualGroupBy || !groupBy.length) {\n      return rows\n    }\n    if (debug) console.info('getGroupedRows')\n    // Find the columns that can or are aggregating\n\n    // Uses each column to aggregate rows into a single value\n    const aggregateRowsToValues = rows => {\n      const values = {}\n      columns.forEach(column => {\n        const columnValues = rows.map(d => d.values[column.id])\n        let aggregate =\n          userAggregations[column.aggregate] ||\n          aggregations[column.aggregate] ||\n          column.aggregate\n        if (typeof aggregate === 'function') {\n          values[column.id] = aggregate(columnValues, rows)\n        } else if (aggregate) {\n          throw new Error(\n            `Invalid aggregate \"${aggregate}\" passed to column with ID: \"${\n              column.id\n            }\"`\n          )\n        } else {\n          values[column.id] = columnValues[0]\n        }\n      })\n      return values\n    }\n\n    // Recursively group the data\n    const groupRecursively = (rows, groupBy, depth = 0) => {\n      // This is the last level, just return the rows\n      if (depth >= groupBy.length) {\n        return rows\n      }\n\n      // Group the rows together for this level\n      let groupedRows = Object.entries(groupByFn(rows, groupBy[depth])).map(\n        ([groupByVal, subRows], index) => {\n          // Recurse to sub rows before aggregation\n          subRows = groupRecursively(subRows, groupBy, depth + 1)\n\n          const values = aggregateRowsToValues(subRows)\n\n          const row = {\n            groupByID: groupBy[depth],\n            groupByVal,\n            values,\n            subRows,\n            depth,\n            index\n          }\n          return row\n        }\n      )\n\n      return groupedRows\n    }\n\n    // Assign the new data\n    return groupRecursively(rows, groupBy)\n  }, [rows, groupBy, columns, manualGroupBy])\n\n  return {\n    ...props,\n    rows: groupedRows\n  }\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\nimport {\n  mergeProps,\n  applyPropHooks,\n  getFirstDefined,\n  defaultOrderByFn,\n  defaultSortByFn\n} from '../utils'\n\ndefaultState.sortBy = []\n\naddActions({\n  sortByChange: '__sortByChange__'\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      sortByFn: PropTypes.func,\n      efaultSortDesc: PropTypes.bool\n    })\n  ),\n  sortByFn: PropTypes.func,\n  manualSorting: PropTypes.bool,\n  disableSorting: PropTypes.bool,\n  defaultSortDesc: PropTypes.bool,\n  disableMultiSort: PropTypes.bool\n}\n\nexport const useSortBy = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useSortBy')\n\n  const {\n    debug,\n    rows,\n    columns,\n    orderByFn = defaultOrderByFn,\n    sortByFn = defaultSortByFn,\n    manualSorting,\n    disableSorting,\n    defaultSortDesc,\n    hooks,\n    state: [{ sortBy }, setState]\n  } = props\n\n  columns.forEach(column => {\n    const { accessor, canSortBy } = column\n    column.canSortBy = accessor\n      ? getFirstDefined(\n        canSortBy,\n        disableSorting === true ? false : undefined,\n        true\n      )\n      : false\n  })\n\n  // Updates sorting based on a columnID, desc flag and multi flag\n  const toggleSortByID = (columnID, desc, multi) => {\n    return setState(old => {\n      const { sortBy } = old\n\n      // Find the column for this columnID\n      const column = columns.find(d => d.id === columnID)\n      const resolvedDefaultSortDesc = getFirstDefined(\n        column.defaultSortDesc,\n        defaultSortDesc\n      )\n\n      // Find any existing sortBy for this column\n      const existingSortBy = sortBy.find(d => d.id === columnID)\n      const hasDescDefined = typeof desc !== 'undefined' && desc !== null\n\n      let newSortBy = []\n\n      // What should we do with this filter?\n      let action\n\n      if (!multi) {\n        if (sortBy.length <= 1 && existingSortBy) {\n          if (existingSortBy.desc) {\n            action = 'remove'\n          } else {\n            action = 'toggle'\n          }\n        } else {\n          action = 'replace'\n        }\n      } else {\n        if (!existingSortBy) {\n          action = 'add'\n        } else {\n          if (hasDescDefined) {\n            action = 'set'\n          } else {\n            action = 'toggle'\n          }\n        }\n      }\n\n      if (action === 'replace') {\n        newSortBy = [\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : resolvedDefaultSortDesc\n          }\n        ]\n      } else if (action === 'add') {\n        newSortBy = [\n          ...sortBy,\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : resolvedDefaultSortDesc\n          }\n        ]\n      } else if (action === 'set') {\n        newSortBy = sortBy.map(d => {\n          if (d.id === columnID) {\n            return {\n              ...d,\n              desc\n            }\n          }\n          return d\n        })\n      } else if (action === 'toggle') {\n        newSortBy = sortBy.map(d => {\n          if (d.id === columnID) {\n            return {\n              ...d,\n              desc: !existingSortBy.desc\n            }\n          }\n          return d\n        })\n      } else if (action === 'remove') {\n        newSortBy = []\n      }\n\n      return {\n        ...old,\n        sortBy: newSortBy\n      }\n    }, actions.sortByChange)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      if (column.canSortBy) {\n        column.toggleSortBy = (desc, multi) =>\n          toggleSortByID(column.id, desc, multi)\n      }\n    })\n    return columns\n  })\n\n  hooks.getSortByToggleProps = []\n\n  const addSortByToggleProps = (columns, api) => {\n    columns.forEach(column => {\n      const { canSortBy } = column\n      column.getSortByToggleProps = props => {\n        return mergeProps(\n          {\n            onClick: canSortBy\n              ? e => {\n                e.persist()\n                column.toggleSortBy(\n                  undefined,\n                  !api.disableMultiSort && e.shiftKey\n                )\n              }\n              : undefined,\n            style: {\n              cursor: canSortBy ? 'pointer' : undefined\n            },\n            title: 'Toggle SortBy'\n          },\n          applyPropHooks(api.hooks.getSortByToggleProps, column, api),\n          props\n        )\n      }\n    })\n    return columns\n  }\n\n  hooks.columns.push(addSortByToggleProps)\n  hooks.headers.push(addSortByToggleProps)\n\n  // Mutate columns to reflect sorting state\n  columns.forEach(column => {\n    const { id } = column\n    column.sorted = sortBy.find(d => d.id === id)\n    column.sortedIndex = sortBy.findIndex(d => d.id === id)\n    column.sortedDesc = column.sorted ? column.sorted.desc : undefined\n  })\n\n  const sortedRows = useMemo(() => {\n    if (manualSorting || !sortBy.length) {\n      return rows\n    }\n    if (debug) console.info('getSortedRows')\n\n    const sortMethodsByColumnID = {}\n\n    columns\n      .filter(col => col.sortMethod)\n      .forEach(col => {\n        sortMethodsByColumnID[col.id] = col.sortMethod\n      })\n\n    const sortData = rows => {\n      // Use the orderByFn to compose multiple sortBy's together.\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      const sortedData = orderByFn(\n        rows,\n        sortBy.map(sort => {\n          // Support custom sorting methods for each column\n          const columnSortBy = sortMethodsByColumnID[sort.id]\n\n          // Return the correct sortFn\n          return (a, b) =>\n            (columnSortBy || sortByFn)(\n              a.values[sort.id],\n              b.values[sort.id],\n              sort.desc\n            )\n        }),\n        // Map the directions\n        sortBy.map(d => !d.desc)\n      )\n\n      // TODO: this should be optimized. Not good to loop again\n      sortedData.forEach(row => {\n        if (!row.subRows) {\n          return\n        }\n        row.subRows = sortData(row.subRows)\n      })\n\n      return sortedData\n    }\n\n    return sortData(rows)\n  }, [rows, columns, sortBy, manualSorting])\n\n  return {\n    ...props,\n    rows: sortedRows\n  }\n}\n","import { useMemo, useLayoutEffect } from 'react'\nimport PropTypes from 'prop-types'\n\n//\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.pageSize = 10\ndefaultState.pageIndex = 0\n\naddActions({\n  pageChange: '__pageChange__'\n})\n\nconst propTypes = {\n  // General\n  manualPagination: PropTypes.bool\n}\n\nexport const usePagination = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'usePagination')\n\n  const {\n    rows,\n    manualPagination,\n    debug,\n    state: [\n      {\n        pageSize,\n        pageIndex,\n        pageCount: userPageCount,\n        filters,\n        groupBy,\n        sortBy\n      },\n      setState\n    ]\n  } = props\n\n  useLayoutEffect(() => {\n    setState(\n      old => ({\n        ...old,\n        pageIndex: 0\n      }),\n      actions.pageChange\n    )\n  }, [filters, groupBy, sortBy])\n\n  const { pages, pageCount } = useMemo(() => {\n    if (manualPagination) {\n      return {\n        pages: [rows],\n        pageCount: userPageCount\n      }\n    }\n    if (debug) console.info('getPages')\n\n    // Create a new pages with the first page ready to go.\n    const pages = rows.length ? [] : [[]]\n\n    // Start the pageIndex and currentPage cursors\n    let cursor = 0\n    while (cursor < rows.length) {\n      const end = cursor + pageSize\n      pages.push(rows.slice(cursor, end))\n      cursor = end\n    }\n\n    const pageCount = pages.length\n\n    return {\n      pages,\n      pageCount,\n      pageOptions\n    }\n  }, [rows, pageSize, userPageCount])\n\n  const pageOptions = [...new Array(pageCount)].map((d, i) => i)\n  const page = manualPagination ? rows : pages[pageIndex] || []\n  const canPreviousPage = pageIndex > 0\n  const canNextPage = pageIndex < pageCount - 1\n\n  const gotoPage = pageIndex => {\n    if (debug) console.info('gotoPage')\n    return setState(old => {\n      if (pageIndex < 0 || pageIndex > pageCount - 1) {\n        return old\n      }\n      return {\n        ...old,\n        pageIndex\n      }\n    }, actions.pageChange)\n  }\n\n  const previousPage = () => {\n    return gotoPage(pageIndex - 1)\n  }\n\n  const nextPage = () => {\n    return gotoPage(pageIndex + 1)\n  }\n\n  const setPageSize = pageSize => {\n    setState(old => {\n      const topRowIndex = old.pageSize * old.pageIndex\n      const pageIndex = Math.floor(topRowIndex / pageSize)\n      return {\n        ...old,\n        pageIndex,\n        pageSize\n      }\n    }, actions.setPageSize)\n  }\n\n  return {\n    ...props,\n    pages,\n    pageOptions,\n    page,\n    canPreviousPage,\n    canNextPage,\n    gotoPage,\n    previousPage,\n    nextPage,\n    setPageSize\n  }\n}\n","import PropTypes from 'prop-types'\n\nimport { getFirstDefined, sum } from '../utils'\n\nexport const actions = {}\n\nconst propTypes = {\n  defaultFlex: PropTypes.number\n}\n\nexport const useFlexLayout = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useFlexLayout')\n\n  const {\n    defaultFlex = 1,\n    hooks: {\n      columns: columnsHooks,\n      getRowProps,\n      getHeaderRowProps,\n      getHeaderProps,\n      getCellProps\n    }\n  } = props\n\n  columnsHooks.push((columns, api) => {\n    const visibleColumns = columns.filter(column => {\n      column.visible =\n        typeof column.show === 'function' ? column.show(api) : !!column.show\n      return column.visible\n    })\n\n    const columnMeasurements = {}\n\n    let sumWidth = 0\n    visibleColumns.forEach(column => {\n      const { width, minWidth } = getSizesForColumn(\n        column,\n        defaultFlex,\n        undefined,\n        undefined,\n        api\n      )\n      if (width) {\n        sumWidth += width\n      } else if (minWidth) {\n        sumWidth += minWidth\n      } else {\n        sumWidth += defaultFlex\n      }\n    })\n\n    const rowStyles = {\n      style: {\n        display: 'flex',\n        minWidth: `${sumWidth}px`\n      }\n    }\n\n    api.rowStyles = rowStyles\n\n    getRowProps.push(() => rowStyles)\n    getHeaderRowProps.push(() => rowStyles)\n\n    getHeaderProps.push(column => ({\n      style: {\n        boxSizing: 'border-box',\n        ...getStylesForColumn(column, columnMeasurements, defaultFlex, api)\n      }\n      // [refKey]: el => {\n      //   renderedCellInfoRef.current[key] = {\n      //     column,\n      //     el\n      //   };\n      // },\n    }))\n\n    getCellProps.push(cell => {\n      return {\n        style: {\n          // display: 'block',\n          // boxSizing: 'border-box',\n          ...getStylesForColumn(\n            cell.column,\n            columnMeasurements,\n            defaultFlex,\n            undefined,\n            api\n          )\n        }\n        // [refKey]: el => {\n        //   renderedCellInfoRef.current[columnPathStr] = {\n        //     column,\n        //     el\n        //   };\n        // }\n      }\n    })\n\n    return columns\n  })\n\n  return props\n}\n\n// Utils\n\nfunction getStylesForColumn(column, columnMeasurements, defaultFlex, api) {\n  const { flex, width, maxWidth } = getSizesForColumn(\n    column,\n    columnMeasurements,\n    defaultFlex,\n    api\n  )\n\n  return {\n    flex: `${flex} 0 auto`,\n    width: `${width}px`,\n    maxWidth: `${maxWidth}px`\n  }\n}\n\nfunction getSizesForColumn(\n  { columns, id, width, minWidth, maxWidth },\n  columnMeasurements,\n  defaultFlex,\n  api\n) {\n  if (columns) {\n    columns = columns\n      .map(column =>\n        getSizesForColumn(column, columnMeasurements, defaultFlex, api)\n      )\n      .filter(Boolean)\n\n    if (!columns.length) {\n      return false\n    }\n\n    const flex = sum(columns.map(col => col.flex))\n    const width = sum(columns.map(col => col.width))\n    const maxWidth = sum(columns.map(col => col.maxWidth))\n\n    return {\n      flex,\n      width,\n      maxWidth\n    }\n  }\n\n  return {\n    flex: width ? 0 : defaultFlex,\n    width:\n      width === 'auto'\n        ? columnMeasurements[id] || defaultFlex\n        : getFirstDefined(width, minWidth, defaultFlex),\n    maxWidth\n  }\n}\n\n// const resetRefs = () => {\n//   if (debug) console.info(\"resetRefs\");\n//   renderedCellInfoRef.current = {};\n// };\n\n// const calculateAutoWidths = () => {\n//   RAF(() => {\n//     const newColumnMeasurements = {};\n//     Object.values(renderedCellInfoRef.current).forEach(({ column, el }) => {\n//       if (!el) {\n//         return;\n//       }\n\n//       let measurement = 0;\n\n//       const measureChildren = children => {\n//         if (children) {\n//           [].slice.call(children).forEach(child => {\n//             measurement = Math.max(\n//               measurement,\n//               Math.ceil(child.offsetWidth) || 0\n//             );\n//             measureChildren(child.children);\n//           });\n//         }\n//         return measurement;\n//       };\n\n//       const parentDims = getElementDimensions(el);\n//       measureChildren(el.children);\n\n//       newColumnMeasurements[column.id] = Math.max(\n//         newColumnMeasurements[column.id] || 0,\n//         measurement + parentDims.paddingLeft + parentDims.paddingRight\n//       );\n//     });\n\n//     const oldKeys = Object.keys(columnMeasurements);\n//     const newKeys = Object.keys(newColumnMeasurements);\n\n//     const needsUpdate =\n//       oldKeys.length !== newKeys.length ||\n//       oldKeys.some(key => {\n//         return columnMeasurements[key] !== newColumnMeasurements[key];\n//       });\n\n//     if (needsUpdate) {\n//       setState(old => {\n//         return {\n//           ...old,\n//           columnMeasurements: newColumnMeasurements\n//         };\n//       }, actions.updateAutoWidth);\n//     }\n//   });\n// };\n","import { useState } from 'react'\n\n// Token pagination behaves a bit differently from\n// index based pagination. This hook aids in that process.\n\nexport const useTokenPagination = () => {\n  const [pageToken, setPageToken] = useState()\n  const [nextPageToken, setNextPageToken] = useState()\n  const [previousPageTokens, setPreviousPageTokens] = useState([])\n  const [pageIndex, setPageIndex] = useState(0)\n\n  // Since we're using pagination tokens intead of index, we need\n  // to be a bit clever with page-like navigation here.\n  const nextPage = () => {\n    setPageIndex(old => old + 1)\n    setPreviousPageTokens(old => [...old, pageToken])\n    setPageToken(nextPageToken)\n  }\n\n  const previousPage = () => {\n    setPageIndex(old => old - 1)\n    setPreviousPageTokens(old =>\n      [...old]\n        .reverse()\n        .slice(1)\n        .reverse()\n    )\n    setPageToken(previousPageTokens[previousPageTokens.length - 1])\n  }\n\n  const resetPagination = () => {\n    setPageToken(undefined)\n    setPageIndex(0)\n    setNextPageToken(undefined)\n    setPreviousPageTokens([])\n  }\n\n  const canPreviousPage = previousPageTokens.length\n  const canNextPage = nextPageToken\n\n  return {\n    setNextPageToken,\n    pageToken,\n    pageIndex,\n    previousPage,\n    nextPage,\n    canPreviousPage,\n    canNextPage,\n    resetPagination\n  }\n}\n"],"names":["getBy","obj","path","def","val","pathObj","makePathArray","reduce","cursor","pathPart","e","defaultOrderByFn","arr","funcs","dirs","_toConsumableArray","sort","rowA","rowB","i","length","sortFn","desc","sortInt","index","defaultSortByFn","a","b","toLowerCase","getFirstDefined","arguments","defaultGroupByFn","rows","grouper","prev","row","resKey","values","Array","isArray","push","defaultFilterFn","id","value","column","undefined","String","includes","setBy","recurse","depth","key","target","_typeof","flexRender","Comp","props","Object","getPrototypeOf","isReactComponent","React","mergeProps","groups","forEach","style","className","rest","filter","Boolean","join","applyHooks","hooks","initial","args","next","applyPropHooks","sum","curr","flattenDeep","replace","split","newArr","defaultState","defaultReducer","old","newState","useTableState","initialState","overrides","reducer","useState","state","setState","useMemo","keys","updater","type","renderErr","propTypes","data","PropTypes","array","isRequired","debug","bool","useTable","checkPropTypes","userState","process","env","NODE_ENV","api","beforeRender","columns","headers","headerGroups","renderableRows","getTableProps","getRowProps","getHeaderRowProps","getHeaderProps","getCellProps","console","time","plugins","timeEnd","render","userProps","Error","headerGroup","header","visible","prepareRow","visibleColumns","cells","map","cell","columnPathStr","arrayOf","shape","Cell","any","Header","useColumns","userColumns","groupBy","info","columnTree","decorateColumnTree","parent","decorateColumn","flattenBy","maxDepth","removeChildColumns","buildGroup","parentColumns","hasParents","some","col","isFirst","latestParentColumn","reverse","originalID","placeholderColumn","makeHeaderGroups","g","find","findMaxDepth","Math","max","accessor","accessorString","error","show","childKey","flatColumns","d","subRowsKey","string","useRows","accessRow","originalRow","original","subRows","unpreparedAccessWarning","actions","addActions","acts","expanded","toggleExpanded","useExpanded","expandedKey","toggleExpandedByPath","set","existing","expandedRows","handleRow","parentPath","isExpanded","expandedDepth","findExpandedDepth","filters","setFilter","setAllFilters","filterFn","func","filterAll","canFilter","Filter","manualFilters","useFilters","disableFilters","filterValue","filteredRows","filterRows","entries","filteredSoFar","columnID","filterable","filterMethod","average","round","toggleGroupBy","aggregate","canGroupBy","Aggregated","groupByFn","manualGrouping","aggregations","object","useGroupBy","manualGroupBy","disableGrouping","userAggregations","grouped","toggle","getGroupByToggleProps","addGroupByToggleProps","onClick","persist","title","groupRecursively","groupByVal","columnValues","groupByID","sortBy","sortByChange","sortByFn","efaultSortDesc","manualSorting","disableSorting","defaultSortDesc","disableMultiSort","useSortBy","orderByFn","canSortBy","toggleSortBy","multi","action","resolvedDefaultSortDesc","existingSortBy","hasDescDefined","newSortBy","getSortByToggleProps","addSortByToggleProps","shiftKey","sorted","sortedIndex","findIndex","sortedDesc","sortMethodsByColumnID","sortMethod","sortData","sortedData","columnSortBy","pageSize","pageIndex","pageChange","manualPagination","usePagination","userPageCount","pageCount","useLayoutEffect","pages","end","slice","pageOptions","page","gotoPage","canPreviousPage","canNextPage","previousPage","nextPage","setPageSize","topRowIndex","floor","defaultFlex","number","useFlexLayout","columnsHooks","columnMeasurements","sumWidth","getSizesForColumn","width","minWidth","rowStyles","display","boxSizing","getStylesForColumn","flex","maxWidth","useTokenPagination","pageToken","setPageToken","nextPageToken","setNextPageToken","previousPageTokens","setPreviousPageTokens","setPageIndex","resetPagination"],"mappings":"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"}